# 一、进程

- **进程相关命令：**
  - **查看进程 -  ps aux | grep 【进程号】**
  - **动态显示 - top** 
  - **杀掉进程 - kill 【进程号】**
    - -9 强制
    - killall 删除所有重名的进程
- **检测内存泄露命令:**
  - **valgrind 【./a.out】** 


## 01. 进程和程序

**什么是程序？**

​		程序是存放在磁盘上的一个可执行文件，程序是静态的。

**什么是进程？**

​		进程是程序执行的一个过程，进程是动态的，其包括进程的创建、调度和消亡。进程拥有在自己的独立环境和系统资源。

## 02. 并行和并发

**什么是并行？**

​		并行：在同一时刻，有多条指令在多个处理器上同时执行。

**什么是并发？**

​		并发：在同一时刻只有一条指令执行，但多个进程指令被快速的切换执行，使得在宏观上具有多个进程同时执行的效果，但微观上并不是同时执行，只是把时间分为若干段，使多个进程快速交替地执行。

## 03. 进程的状态

**进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转变。**

**状态分为三态模型和五态模型：**

​		三态：运行态、就绪态、阻塞态。

​		五态： 新建态、终止态、运行态、就绪态、阻塞态。

## 04. 进程号的相关函数

**获取进程号 getpid()**

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
功能:
	- 获取本进程号
参数:
	- 无
返回值:
	- 返回本进程号
```

**获取父进程号 getppid()**

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getppid(void);
功能:
	- 获取调用此函数的进程的父进程号
参数:
	- 无
返回值:
	- 返回调用此函数的进程的父进程号
```

**获取进程组号 getpgid()**

```c
#include <unistd.h>

pid_t getpgid(pid_t pid);
功能:
	- 获取进程组号
参数:
	- 进程号
返回值:
	- 参数为0时返回当前进程组好，否则返回参数指定的进程的进程组号
```

## 05. 进程的创建

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
功能:
	- 从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程
参数:
	- 无
返回值:
	- 成功: 子进程返回0，父进程中返回子进程ID
    - 失败: 返回-1
    	- 原因:
        	1.当前的进程数已经达到系统规定的上限，errno = EAGAIN
            2.系统内存不足，errno = ENOMEM
```

**示例代码：**

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    //创建子进程
	fork();

	printf("hello,world\n");
	return 0;
}

输出:
	hello,world
    hello,world
```

## 06. 区分父子进程

**示例代码：**

```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;

	pid = fork();

	if (pid < 0)
	{
		printf("fork err...\n");
		return 0;
	}
	// 子进程
	if (0 == pid)
	{
		while (1)
		{
			printf("I'm son , mypid = %d , myfatherpid = %d\n", getpid(), getppid());
			sleep(1);
		}
	}
    // 父进程
	if (pid > 0)
	{
		while (1)
		{
			printf("I'm father , mypid = %d , mysonpid = %d\n", getpid(), pid);
			sleep(1);
		}
	}
    
	return 0;
}
```

## 07. GDB调试多进程

**默认跟踪父进程，如果要跟踪子进程，要在fork之前设置以下命令**

- **set follow-fork-mode child**      跟踪子进程
- **set follow-fork-mode parent**  设置跟踪父进程

## 08. 进程退出函数

**exit() - 标准库函数，刷新缓冲区**

**_exit() - 系统调用函数，不做任何处理，直接退出**

**_Exit() - 功能和 _exit一样**

```c
#include <stdlib.h>
void exit(int status);

#include <unistd.h>
void _exit(int status);
功能:
	- 结束调用此函数的进程
参数:
	- status
返回值:
	- 无
```

## 09. 回收子进程函数

**wait() - 阻塞**

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
功能：
    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。
参数：
    status : 进程退出时的状态信息。
返回值：
    成功：已经结束子进程的进程号
    失败： -1
```

**waitpid() - 不阻塞，可指定子进程pid**

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
功能：
    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。

参数：
    pid : 参数 pid 的值有以下几种类型：
      pid > 0  等待进程 ID 等于 pid 的子进程。
      pid = 0  等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。
      pid = -1 等待任一子进程，此时 waitpid 和 wait 作用一样。
      pid < -1 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。

    status : 进程退出时的状态信息。和 wait() 用法一样。

    options : options 提供了一些额外的选项来控制 waitpid()。
            0：同 wait()，阻塞父进程，等待子进程退出。
            WNOHANG：没有任何已经结束的子进程，则立即返回。
            WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）
                 
返回值：
    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 3 种情况：
        1) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；
        2) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 0；
        3) 如果调用中出错，则返回-1，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；
```

**示例代码：**

```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main()
{
	pid_t pid;
	int status;

	pid = fork();

	if (pid < 0)
	{
		printf("fork err...\n");
		return 0;
	}
	//子进程
	if (0 == pid)
	{
		for (int i = 0; i < 5; i++)
		{
			printf("I am son , mypid = %d , doing %d \n", getpid(), i + 1);
			sleep(1);
		}
		exit(15);
	}

	//父进程回收子进程
	printf("父进程正在等待子进程工作结束，并回收子进程资源...\n");

	//int ret = wait(&status);
	//int ret = waitpid(-1, &status, 0); //等同 wait
	int ret = waitpid(-1, &status, WNOHANG);  //不阻塞
	if (ret == -1)
	{
		perror("wait");
		return 0;
	}
	printf("子进程工作结束，父进程回收资源成功...\n");

	//正常退出
	if (WIFEXITED(status))
	{
		printf("子进程退出状态码:%d \n", WEXITSTATUS(status));
	}
	else if (WIFSIGNALED(status))
	{
		// kill 
		printf("子进程被信号%d杀死了... \n", WTERMSIG(status));
	}
	else if (WIFSTOPPED(status))
	{
		// kill -19 【pid】暂停
		// kill -18 【pid】唤醒

		printf("子进程被信号%d暂停了... \n", WSTOPSIG(status));
	}
    
	return 0;
}
```

## 10. 孤儿进程

父进程退出，子进程还在执行，这个子进程就称为孤儿进程。最终由内核把这个孤儿进程的父进程设置为init,并循环的wait孤儿进程，所以孤儿进程并不会有危害。

## 11. 僵尸进程

子进程已经退出了，但父进程还在并没有回收子进程的资源，子进程就变成僵尸进程，存留在内核。僵尸进程会占用资源，应当避免僵尸进程。

## 12. 进程替换

**概述**

在 Windows 平台下，我们可以通过双击运行可执行程序，让这个可执行程序成为一个进程；而在 Linux 平台，我们可以通过 ./ 运行，让一个可执行程序成为一个进程。

但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢？这里我们通过 exec 函数族实现。

exec 函数族，顾名思义，就是一簇函数，在 Linux 中，并不存在 exec() 函数，exec 指的是一组函数，一共有 6 个：

```c
#include <unistd.h>
extern char **environ;
int execl(const char *path, const char *arg, .../* (char  *) NULL */);
int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
int execve(const char *filename, char *const argv[], char *const envp[]);
```

**示例代码：**

```c
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main()
{
	printf("hello,world... \n");
    
	execlp("cat", "cat","/home/niuzi/client.json", NULL);
    
	printf("hello,world \n");
    
	return 0;
}
```

# 二、进程间通信

## 01. 无名管道

- **特点：**

  - 半双工，一端读一端写
  - 遵循先进先出规则
  - 管道不是文件，他只存在于内存。
  - 只能在有公共祖先的进程之间使用
    - 父子进程
    - 兄弟进程

- **无名管道创建：**

  - pipe函数


  ```c
  #include <unistd.h>
  
  int pipe(int pipefd[2]);
  功能：创建无名管道。
      
  参数：
      pipefd : 为 int 型数组的首地址，其存放了管道的文件描述符 pipefd[0]、pipefd[1]。
      
      当一个管道建立时，它会创建两个文件描述符 fd[0] 和 fd[1]。其中 fd[0] 固定用于读管道，而 fd[1] 固定用于写管道。一般文件 I/O的函数都可以用来操作管道(lseek() 除外)。
  
  返回值：
      成功：0
      失败：-1
  ```

  **父子进程通过无名管道通信示例代码：**

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/wait.h>
  #include <string.h>
  
  int main()
  {
  	int pipefd[2];
  
  	char readbuf[128];
  	char* str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  
  	int ret = pipe(pipefd);
  	if (ret < 0)
  	{
  		perror("pipe");
  		return 1;
  	}
  
  	ret = fork();
  	if (ret < 0)
  	{
  		perror("fork");
  		return 1;
  	}
  	else if (0 == ret)
  	{
  		close(pipefd[1]);
  		memset(readbuf, 0, 128);
  
  		read(pipefd[0], readbuf, 128);
  		printf("I'm son , mypid = %d ,my father pid = %d ,I read buf = %s\n", getpid(), getppid(), readbuf);
  		close(pipefd[0]);
  
  	}
  	else
  	{
  		close(pipefd[0]);
  
  		write(pipefd[1], str, strlen(str));
  		printf("I'am father , mysonpid = %d , mypid = %d \n", ret, getpid());
  
  		close(pipefd[1]);
  	}
  
  	getchar();
  
  	return 0;
  }
  ```

- **无名管道读写特点：**

  - 如果写端全部被关闭，则读端读取管道剩余数据完，再次read函数返回0，就像读到文件末尾。

  - 如果写端未被关闭，但并未写入数据，则读端都区管道剩余数据完，再次read函数会阻塞，直到读到新的数据才返回

  - 如果读端全部被关闭，则写端会收到SIGPIPE信号，进程异常终止，也可以捕获信号，不终止进程

  - 如果读端没有被关闭，也没有读取数据，则写端写满管道缓冲区后，再次write函数会阻塞，直到管道有空余空间。

- **设置非阻塞与还原阻塞方法**

  - 非阻塞

    ```c
    #include <fcntl.h>
    
    int flags = fcntl(fd[0],F_GETFL)
    flags |= O_NONBLOCK
    fcntl(fd[0],F_SETFL,flags);
    ```

  - 还原阻塞

    ```c
    #include <fcntl.h>
    
    int flags = fcntl(fd[0],F_GETFL);
    flags &= ~O_NONBLOCK
    fcntl(fd[0],F_SETFL,flags);
    ```

## 02. 有名管道

- **概述：**

  命名管道（FIFO）不同于无名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。

   

  命名管道（FIFO)和无名管道（pipe）有一些特点是相同的，不一样的地方在于：

  1) FIFO 在文件系统中作为一个特殊的文件而存在，但 FIFO 中的内容却存放在**内存**中。

  2) 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。

  3) FIFO 有名字，不相关的进程可以通过打开命名管道进行通信。

- **命令创建有名管道：**

  mkfifo 【管道名字】

- **函数创建有名管道：**

  ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  
  int mkfifo(const char *pathname, mode_t mode);
  功能：
      命名管道的创建。
  参数：
      pathname : 普通的路径名，也就是创建后 FIFO 的名字。
      mode : 文件的权限，与打开普通文件的 open() 函数中的 mode 参数相同。(0666)
  返回值：
      成功：0   状态码
      失败：如果文件已经存在，则会出错且返回 -1。
  ```

- **有名管道多进程简易版聊天示例代码：**

  ```c
  //write
  #include <stdio.h>
  #include <sys/types.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/stat.h>
  #include <string.h>
  #include <fcntl.h>
  #include <sys/wait.h>
  #define SIZE 128
  
  int main()
  {
  
  	char writebuf[SIZE];
  	char readbuf[SIZE];
  	int status;
  	int ret = -1;
  
  	int fd1 = open("fifo1", O_WRONLY);
  	if (fd1 < 0)
  	{
  		perror("open");
  		return 1;
  	}
  	int fd2 = open("fifo2", O_RDONLY);
  
  	if (fd2 < 0)
  	{
  		perror("open");
  		return 1;
  	}
  
  	ret = fork();
  	if (ret < 0)
  	{
  		perror("fork");
  		return 1;
  	}
  	else if (ret == 0)
  	{
  		while (1)
  		{
  			memset(readbuf, 0, SIZE);
  			int n = read(fd2, readbuf, SIZE);
  			if (n <= 0)
  			{
  				perror("read");
  				break;
  
  
  			}
  			printf("【read:】 %s\n", readbuf);
  		}
  	}
  	else
  	{
  		while (1)
  		{
  			memset(writebuf, 0, SIZE);
  
  			fgets(writebuf, SIZE, stdin);
  
  			write(fd1, writebuf, strlen(writebuf));
  
  			printf("【write:】%s\n", writebuf);
  
  		}
  	}
  
  	close(fd1);
  	close(fd2);
  
  
  	return 0;
  }
  
  //read
  #include <stdio.h>
  #include <sys/types.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/stat.h>
  #include <string.h>
  #include <fcntl.h>
  #include <sys/wait.h>
  #define SIZE 128
  
  int main()
  {
  	int status;
  	char writebuf[SIZE];
  	char readbuf[SIZE];
  
  	int ret = -1;
  
  	int fd1 = open("fifo1", O_RDONLY);
  	if (fd1 < 0)
  	{
  		perror("open");
  		return 1;
  	}
  	int fd2 = open("fifo2", O_WRONLY);
  
  	if (fd2 < 0)
  	{
  		perror("open");
  		return 1;
  	}
  
  	ret = fork();
  	if (ret < 0)
  	{
  		perror("fork");
  		return 1;
  	}
  	else if (ret == 0)
  	{
  		while (1)
  		{
  			memset(readbuf, 0, SIZE);
  
  			int n = read(fd1, readbuf, SIZE);
  			if (n <= 0)
  			{
  				perror("read");
  				break;
  
  			}
  			printf("【read:】 %s\n", readbuf);
  		}
  	}
  	else
  	{
  		while (1)
  		{
  			memset(writebuf, 0, SIZE);
  
  			fgets(writebuf, SIZE, stdin);
  
  			write(fd2, writebuf, strlen(writebuf));
  
  			printf("【write:】%s\n", writebuf);
  		}
  
  
  	}
  
  	close(fd1);
  	close(fd2);
  
  
  	return 0;
  }
  ```

## 03. 共享存储映射

- **概述：**

  存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。

  于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可	在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。

- **存储映射操作函数：**

  - **mmap函数**

    ```c
    #include <sys/mman.h>
    
    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
    功能:
        一个文件或者其它对象映射进内存
    参数：
        addr :  指定映射的起始地址, 通常设为NULL, 由系统指定
        length：映射到内存的文件长度
        prot：  映射区的保护方式, 最常用的 :
            a) 读：PROT_READ
            b) 写：PROT_WRITE
            c) 读写：PROT_READ | PROT_WRITE
        flags：  映射区的特性, 可以是
            a) MAP_SHARED : 写入映射区的数据会复制回文件, 且允许其他映射该文件的进程共享。
            b) MAP_PRIVATE : 对映射区的写入操作会产生一个映射区的复制(copy - on - write), 对此区域所做的修改不会写回原文件。
        fd：由open返回的文件描述符, 代表要映射的文件。
        offset：以文件开始处的偏移量, 必须是4k的整数倍, 通常为0, 表示从文件头开始映射
    返回值：
        成功：返回创建的映射区首地址
        失败：MAP_FAILED宏
                
                
    关于mmap函数的使用总结：
    
    1) 第一个参数写成NULL
    
    2) 第二个参数要映射的文件大小 > 0
    
    3) 第三个参数：PROT_READ 、PROT_WRITE
    
    4) 第四个参数：MAP_SHARED 或者 MAP_PRIVATE
    
    5) 第五个参数：打开的文件对应的文件描述符
    
    6) 第六个参数：4k的整数倍，通常为0
    ```

  - **munmap函数**

    ```c
    #include <sys/mman.h>
    
    int munmap(void *addr, size_t length);
    功能：
        释放内存映射区
    参数：
        addr：使用mmap函数创建的映射区的首地址
        length：映射区的大小
    返回值：
        成功：0
        失败：-1
    ```


# 三、信号

## 01. 概述

信号是 Linux 进程间通信的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式 。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。

“中断”在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给“中断”了，我去签收快递( 处理中断 )，处理完成后，再继续玩我的游戏。

这里我们学习的“信号”就是属于这么一种“中断”。我们在终端上敲“Ctrl+c”，就产生一个“中断”，相当于产生一个信号，接着就会处理这么一个“中断任务”（默认的处理方式为中断当前进程）。

## 02. 信号四要素

每个信号必备4要素，分别是：

1）编号 2）名称 3）事件 4）默认处理动作

可通过**man 7 signal**查看帮助文档获取：

Action为默认动作：

- Term：终止进程
- Ign： 忽略信号 (默认即时对该种信号忽略操作)
- Core：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)
- Stop：停止（暂停）进程
- Cont：继续运行进程

**9) SIGKILL** **和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。**

另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！

## 03. 阻塞信号集和未决信号集

信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。

Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指**阻塞信号集和未决信号集**。

**6.1 阻塞信号集(信号屏蔽字)**

将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发生在解除屏蔽后)。

**6.2 未决信号集**

信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。

信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。

## 04. 信号产生的相关函数

- **kill**

  ```c
  int main()
  {
      pid_t pid = fork();
      if (pid == 0)
      {//子进程
          int i = 0;
          for (i = 0; i<5; i++)
          {
              printf("in son process\n");
              sleep(1);
          }
      }
      else
      {//父进程
          printf("in father process\n");
          sleep(2);
          printf("kill sub process now \n");
          kill(pid, SIGINT);
      }
      return 0;
  }
  ```

- **raise**

  ```c
  #include <signal.h>
  
  int raise(int sig);
  功能：给当前进程发送指定信号(自己给自己发)，等价于 kill(getpid(), sig)
  参数：
      sig：信号编号
  返回值：
      成功：0
      失败：非0值
  ```

- **abort**

  ```c
  #include <stdlib.h>
  
  void abort(void);
  功能：给自己发送异常终止信号 6) SIGABRT，并产生core文件，等价于kill(getpid(), SIGABRT);
  
  参数：无
  
  返回值：无
  ```

- **alarm**

  ```c
  #include <unistd.h>
  
  unsigned int alarm(unsigned int seconds);
  功能：
      设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。
      取消定时器alarm(0)，返回旧闹钟余下秒数。
  参数：
      seconds：指定的时间，以秒为单位
  返回值：
      返回0或剩余的秒数
  
      
      
  int main()
  {
      int seconds = 0;
  
      seconds = alarm(5);
      printf("seconds = %d\n", seconds);
  
      sleep(2);
      seconds = alarm(5);
      printf("seconds = %d\n", seconds);
  
      while (1);
      return 0;
  }
  ```

- **settitimer**

  ```c
  #include <sys/time.h>
  
  int setitimer(int which,  const struct itimerval *new_value, struct itimerval *old_value);
  功能：
      设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。
  参数：
      which：指定定时方式
          a) 自然定时：ITIMER_REAL → 14）SIGALRM计算自然时间
          b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM  只计算进程占用cpu的时间
          c) 运行时计时(用户 + 内核)：ITIMER_PROF → 27）SIGPROF计算占用cpu及执行系统调用的时间
      new_value：struct itimerval, 负责设定timeout时间
          struct itimerval {
              struct timerval it_interval; // 闹钟触发周期
              struct timerval it_value;    // 闹钟触发时间
          };
          struct timeval {
              long tv_sec;            // 秒
              long tv_usec;           // 微秒
          }
          itimerval.it_value： 设定第一次执行function所延迟的秒数 
          itimerval.it_interval：  设定以后每几秒执行function
  
      old_value： 存放旧的timeout值，一般指定为NULL
  返回值：
      成功：0
      失败：-1
              
  void myfunc(int sig)
  {
      printf("hello\n");
  }
  
  int main()
  {
      struct itimerval new_value;
  
      //定时周期
      new_value.it_interval.tv_sec = 1;
      new_value.it_interval.tv_usec = 0;
  
      //第一次触发的时间
      new_value.it_value.tv_sec = 2;
      new_value.it_value.tv_usec = 0;
  
      signal(SIGALRM, myfunc); //信号处理
      setitimer(ITIMER_REAL, &new_value, NULL); //定时器设置
  
      while (1);
  
      return 0;
  }
  
  ```

## 05. 信号集

在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。

这两个信号集都是内核使用**位图机制**来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。

## 06. 自定义信号集函数

**相关函数：**

```c
#include <signal.h>  

int sigemptyset(sigset_t *set);       //将set集合置空
int sigfillset(sigset_t *set)；          //将所有信号加入set集合
int sigaddset(sigset_t *set, int signo);  //将signo信号加入到set集合
int sigdelset(sigset_t *set, int signo);   //从set集合中移除signo信号
int sigismember(const sigset_t *set, int signo); //判断信号是否存在
```

**示例代码：**

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void show_signal(sigset_t *s)
{
        for(int i = 1;i<32;i++)
        {

                if(sigismember(s,i))
                {
                        printf("1");
                }
                else
                {
                        printf("0");
                }
        }

        printf("\n");
}


int main()
{

        sigset_t set;
        //清空集合
        sigemptyset(&set);
        //遍历集合，1 该位存在信号，0不存在信号
        show_signal(&set);
        //将所有信号添加到集合里
        sigfillset(&set);
        show_signal(&set);
        //将某信号从该集合移除
        sigdelset(&set,SIGHUP);
        sigdelset(&set,SIGBUS);
        show_signal(&set);
        //将某信号添加至该集合
        sigaddset(&set,SIGHUP);
        show_signal(&set);


   return 0;
}
```

## 07. 信号屏蔽

- **sigprocmask函数**

  信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。

  所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。

  我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。

  ```c
  #include <signal.h>
  
  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
  功能：
      检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 set 指定，而原先的信号阻塞集合由 oldset 保存。
  
  参数：
      how : 信号阻塞集合的修改方法，有 3 种情况：
          SIG_BLOCK：向信号阻塞集合中添加 set 信号集，新的信号掩码是set和旧信号掩码的并集。相当于 mask = mask|set。
          SIG_UNBLOCK：从信号阻塞集合中删除 set 信号集，从当前信号掩码中去除 set 中的信号。相当于 mask = mask & ~ set。
          SIG_SETMASK：将信号阻塞集合设为 set 信号集，相当于原来信号阻塞集的内容清空，然后按照 set 中的信号重新设置信号阻塞集。相当于mask = set。
      set : 要操作的信号集地址。
          若 set 为 NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。
      oldset : 保存原先信号阻塞集地址
  
  返回值：
      成功：0，
      失败：-1，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。
  ```

  **示例代码：**

  ```c
  void fun2(int signum)
  {
          printf("捕捉到信号%d\n",signum);
  }
  int main()
  {
  
          signal(SIGINT,fun1);
  
          signal(SIGQUIT,fun2);
  
          printf("请按下任意键设置屏蔽信号\n");
  
          getchar();
  		//新的阻塞集为set, oldset保存原先阻塞集
          sigset_t set;
          sigset_t oldset;
  		//情况集合
          sigemptyset(&set);
          sigemptyset(&oldset);
  		//添加信号到set集合
          sigaddset(&set,SIGINT);
  		//设置阻塞集
          int ret = sigprocmask(SIG_BLOCK,&set,&oldset);
          if(ret == -1)
          {
  
                  perror("sigprocmask");
                  return 1;
  
          }
          printf("设置信号屏蔽成功...\n");
  
          printf("请按下任意键解除屏蔽...\n");
          getchar();
      	//将原先的阻塞集清空
          ret = sigprocmask(SIG_SETMASK,&oldset,NULL);
          if(ret == -1)
          {
                  perror("sigprocmask");
                  return 1;
          }
  
          printf("信号屏蔽解除成功");
  
     return 0;
  }
  ```

## 08. 获取未决信号

- **sigpending函数**

  ```c
  #include <signal.h>
  
  int sigpending(sigset_t *set);
  功能：读取当前进程的未决信号集
  参数：
      set：未决信号集
  返回值：
      成功：0
      失败：-1
  
  ```

## 09. 信号捕捉

- **signal函数**

  ```c
  #include <signal.h>
  
  typedef void(*sighandler_t)(int);
  sighandler_t signal(int signum, sighandler_t handler);
  功能：
      注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。
  
  参数：
      signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l("l" 为字母)进行相应查看。
      handler : 取值有 3 种情况：
            SIG_IGN：忽略该信号
            SIG_DFL：执行系统默认动作
            信号处理函数名：自定义信号处理函数，如：func
            回调函数的定义如下：
              void func(int signo)
              {
                  // signo 为触发的信号，为 signal() 第一个参数的值
              }
  
  返回值：
      成功：第一次返回 NULL，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。
      失败：返回 SIG_ERR
  ```

- **sigaction函数**

  ```c
  #include <signal.h>
  
  int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
  功能：
      检查或修改指定信号的设置（或同时执行这两种操作）。
  
  参数：
      signum：要操作的信号。
      act：   要设置的对信号的新处理方式（传入参数）。
      oldact：原来对信号的处理方式（传出参数）。
  
      如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。
  
  返回值：
      成功：0
      失败：-1
      
      
      struct sigaction {
      void(*sa_handler)(int); //旧的信号处理函数指针
      void(*sa_sigaction)(int, siginfo_t *, void *); //新的信号处理函数指针
      sigset_t   sa_mask;      //信号阻塞集
      int        sa_flags;     //信号处理的方式
      void(*sa_restorer)(void); //已弃用
  };
  
  1) sa_handler、sa_sigaction：信号处理函数指针，和 signal() 里的函数指针用法一样，应根据情况给sa_sigaction、sa_handler 两者之一赋值，其取值如下：
  
  a) SIG_IGN：忽略该信号
  
  b) SIG_DFL：执行系统默认动作
  
  c) 处理函数名：自定义信号处理函数
  
  2) sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。
  
  3) sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的“按位或”组合：
  
  Ø SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）
  
  Ø SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。
  
  Ø SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。
  
  Ø SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。
  
  Ø SA_RESETHAND：信号处理之后重新设置为默认的处理方式。
  
  Ø SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。
      
      
  信号处理函数
  void(*sa_sigaction)(int signum, siginfo_t *info, void *context);
  参数说明：
      signum：信号的编号。
      info：记录信号发送进程信息的结构体。
      context：可以赋给指向 ucontext_t 类型的一个对象的指针，以引用在传递信号时被中断的接收进程或线程的上下文。**示例程序**
  ```

- **示例代码：**

  ```C
  void myfunc(int sig)
  {
      printf("hello signal: %d\n", sig);
      sleep(5);
      printf("wake up .....\n");
  }
  
  int main()
  {
      // 注册信号捕捉函数
      struct sigaction act;
      act.sa_flags = 0;
      act.sa_handler = myfunc;
      // 设置临时屏蔽的信号
      sigemptyset(&act.sa_mask);  // 清空
      // ctrl + 反斜杠
      sigaddset(&act.sa_mask, SIGQUIT);
  
      sigaction(SIGINT, &act, NULL); //注册信号
  
      while (1);
  
      return 0;
  }
  ```


# 四、守护进程

## 01. 概述

守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。

守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。

## 02. 模型

- 创建子进程，父进程退出(必须)
  - 所有工作在子进程中进行形式上脱离了控制终端
-  在子进程中创建新会话(必须)
  - setsid()函数
  - 使子进程完全独立出来，脱离控制
- 改变当前目录为根目录(不是必须)
  - chdir()函数
  - 防止占用可卸载的文件系统
  - 也可以换成其它路径
- 重设文件权限掩码(不是必须)
  - umask()函数
  - 防止继承的文件创建屏蔽字拒绝某些权限
  - 增加守护进程灵活性
- 关闭文件描述符(不是必须)
  - 继承的打开文件不会用到，浪费系统资源，无法卸载
- 开始执行守护进程核心工作(必须)

**示例代码：**

```c
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

int main()
{

        pid_t pid;

        pid = fork();
        if(pid < 0)
        {
                perror("fork");
                return 1;
        }
        //父进程退出 使进程形式上脱离终端
        if(pid > 0)
        {
                exit(0);
        }
        //子进程创建会话，成为新的会长，使进程完全脱离终端
        pid = setsid();
        if(pid < 0)
        {
                perror("setsid");
                return 1;
        }
        //改变当前目录为根目录，防止占用可卸载的文件系统
        int ret = chdir("/");
        if(ret < 0)
        {
                perror("chdir");
                return 1;
        }
        //重设文件权限掩码，增加守护进程灵活性
        umask(0);
        //关闭文件描述符。
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);
        //开始守护进程核心工作
        while(1)
        {
                system("date >> /home/niuzi/codeTest/log.txt");
                sleep(1);
        }

        return 0;
}
```

# 五、线程

## 01. 概述

进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，**进程是CPU分配资源的最小单位**。

线程存在与进程当中(进程可以认为是线程的容器)，是操作系统调度执行的最小单位。说通俗点，线程就是干活的。

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。

线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

如果说进程是一个资源管家，负责从主人那里要资源的话，那么线程就是干活的苦力。一个管家必须完成一项工作，就需要最少一个苦力，也就是说，一个进程最少包含一个线程，也可以包含多个线程。苦力要干活，就需要依托于管家，所以说一个线程，必须属于某一个进程。

进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如说堆啊，栈啊，静态存储区什么的。

## 02. 线程常用操作函数

- **线程号**

  - **pthread_self**

    ```c
    #include <pthread.h>
    
    pthread_t pthread_self(void);
    功能：
        获取线程号。
    参数：
        无
    返回值：
        调用线程的线程 ID 
    ```

- **比较线程号是否相等**

  - **pthread_equal**

    ```c
    int pthread_equal(pthread_t t1, pthread_t t2);
    功能：
        判断线程号 t1 和 t2 是否相等。为了方便移植，尽量使用函数来比较线程 ID。
    参数：
        t1，t2：待判断的线程号。
    返回值：
        相等：  非 0
        不相等：0
    ```

- **线程创建**

  - **pthread_create**

    ```c
    #include <pthread.h>
    
    int pthread_create(pthread_t *thread,
                const pthread_attr_t *attr,
                void *(*start_routine)(void *),
                void *arg );
    功能：
        创建一个线程。
    参数：
        thread：线程标识符地址。
        attr：线程属性结构体地址，通常设置为 NULL。
        start_routine：线程函数的入口地址。
        arg：传给线程函数的参数。
    返回值：
        成功：0
        失败：非 0
    ```

- **线程资源回收**

  - **pthread_join**

  - **函数会阻塞**

    ```c
    #include <pthread.h>
    
    int pthread_join(pthread_t thread, void **retval);
    功能：
        等待线程结束（此函数会阻塞），并回收线程资源，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回。
    参数：
        thread：被等待的线程号。
        retval：用来存储线程退出状态的指针的地址。
    返回值：
        成功：0
        失败：非 0
    
    ```

  - **线程分离 pthread_detach**

    ```c
    #include <pthread.h>
    
    int pthread_detach(pthread_t thread);
    功能：
        使调用线程与当前进程分离，分离后不代表此线程不依赖与当前进程，线程分离的目的是将线程资源的回收工作交由系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。
    参数：
        thread：线程号。
    返回值：
        成功：0
        失败：非0
    ```

- **线程退出**

  - **pthread_exit**

    ```c
    #include <pthread.h>
    
    void pthread_exit(void *retval);
    功能：
        退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。
    参数：
        retval：存储线程退出状态的指针。
    返回值：无 
    ```

- **线程取消**

  - **pthread_cancel**

    ```c
    #include <pthread.h>
    
    int pthread_cancel(pthread_t thread);
    功能：
        杀死(取消)线程
    参数：
        thread : 目标线程ID。
    返回值：
        成功：0
        失败：出错编号
    ```

## 03. 线程属性

- **概述**

  - Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。

    如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。

    ```c
    typedef struct
    {
        int             etachstate;     //线程的分离状态
        int             schedpolicy;    //线程调度策略
        struct sched_param  schedparam; //线程的调度参数
        int             inheritsched;   //线程的继承性
        int             scope;      //线程的作用域
        size_t          guardsize;  //线程栈末尾的警戒缓冲区大小
        int             stackaddr_set; //线程的栈设置
        void*           stackaddr;  //线程栈的位置
        size_t          stacksize;  //线程栈的大小
    } pthread_attr_t;
    ```

- **线程属性初始化和销毁**

  ```c
  #include <pthread.h>
  
  int pthread_attr_init(pthread_attr_t *attr);
  功能：
      初始化线程属性函数，注意：应先初始化线程属性，再pthread_create创建线程
  参数：
      attr：线程属性结构体
  返回值：
      成功：0
      失败：错误号
  
  int pthread_attr_destroy(pthread_attr_t *attr);
  功能：
      销毁线程属性所占用的资源函数
  参数：
      attr：线程属性结构体
  返回值：
      成功：0
      失败：错误号
  ```

- **线程分离状态**

  - 线程的分离状态决定一个线程以什么样的方式来终止自己。

    - 非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。
    - 分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。

  - 这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。

    要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。

    设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。

  - ```C
    #include <pthread.h>
    
    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
    功能：设置线程分离状态
    参数：
        attr：已初始化的线程属性
        detachstate：    分离状态
            PTHREAD_CREATE_DETACHED（分离线程）
            PTHREAD_CREATE_JOINABLE（非分离线程）
    返回值：
        成功：0
        失败：非0
    
    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
    功能：获取线程分离状态
    参数：
        attr：已初始化的线程属性
        detachstate：    分离状态
            PTHREAD_CREATE_DETACHED（分离线程）
            PTHREAD _CREATE_JOINABLE（非分离线程）
    返回值：
        成功：0
        失败：非0
    ```

- **线程栈地址**

  - POSIX.1定义了两个常量来检测系统是否支持栈属性：

    - _POSIX_THREAD_ATTR_STACKADDR
    - _POSIX_THREAD_ATTR_STACKSIZE

    也可以给sysconf函数传递来进行检测：

    - _SC_THREAD_ATTR_STACKADDR
    - _SC_THREAD_ATTR_STACKSIZE

    当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。

  ```c
  #include <pthread.h>
  
  int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,  size_t stacksize);
  功能：设置线程的栈地址
  参数：
      attr：指向一个线程属性的指针
      stackaddr：内存首地址
      stacksize：返回线程的堆栈大小
  返回值：
      成功：0
      失败：错误号
  
  int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr,  size_t *stacksize);
  功能：获取线程的栈地址
  参数：
      attr：指向一个线程属性的指针
      stackaddr：返回获取的栈地址
      stacksize：返回获取的栈大小
  返回值：
      成功：0
      失败：错误号
  ```

- **线程栈大小**

  - 当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用,当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小

  ```c
  #include <pthread.h>
  
  int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
  功能：设置线程的栈大小
  参数：
      attr：指向一个线程属性的指针
      stacksize：线程的堆栈大小
  返回值：
      成功：0
      失败：错误号
  
  int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
  功能：获取线程的栈大小
  参数： 
      attr：指向一个线程属性的指针
      stacksize：返回线程的堆栈大小
  返回值：
      成功：0
      失败：错误号
  
  ```


## 04. 线程使用注意事项

- 主线程退出其他线程不退出，主线程应调用pthread_exit
-  避免僵尸线程
  - pthread_join
  -  pthread_detach
  - pthread_create指定分离属性
- 被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;
- malloc和mmap申请的内存可以被其他线程释放
- 应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork的线程存在，其他线程t在子进程中均pthread_exit
-  信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制

# 六、线程同步

## 01. 互斥锁

**同步：**例线程A和线程B，有先后执行顺序

**互斥：**线程A和线程B，在同一时刻，只有一个线程可以执行

## 02. 互斥锁相关函数

- **初始化互斥锁**

  - **pthread_mutex_init**

    ```C
    #include <pthread.h>
    
    int pthread_mutex_init(pthread_mutex_t *restrict mutex,
        const pthread_mutexattr_t *restrict attr);
    功能：
        初始化一个互斥锁。
    参数：
        mutex：互斥锁地址。类型是 pthread_mutex_t 。
        attr：设置互斥量的属性，通常可采用默认属性，即可将 attr 设为 NULL。
    
        可以使用宏 PTHREAD_MUTEX_INITIALIZER 静态初始化互斥锁，比如：
        pthread_mutex_t  mutex = PTHREAD_MUTEX_INITIALIZER;
    
    这种方法等价于使用 NULL 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进行错误检查。
    
    返回值：
        成功：0，成功申请的锁默认是打开的。
        失败：非 0 错误码
        
    restrict，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。
    ```

- **销毁互斥锁**

  - **pthread_mutex_destroy**

    ```c
    #include <pthread.h>
    
    int pthread_mutex_destroy(pthread_mutex_t *mutex);
    功能：
        销毁指定的一个互斥锁。互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源。
    参数：
        mutex：互斥锁地址。
    返回值：
        成功：0
        失败：非 0 错误码
    ```

- **互斥锁上锁**

  - **pthread_mutex_lock**

    ```c
    #include <pthread.h>
    
    int pthread_mutex_lock(pthread_mutex_t *mutex);
    功能：
        对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。
    参数：
        mutex：互斥锁地址。
    返回值：
        成功：0
        失败：非 0 错误码
    
    int pthread_mutex_trylock(pthread_mutex_t *mutex);
       调用该函数时，若互斥锁未加锁，则上锁，返回 0；
       若互斥锁已加锁，则函数直接返回失败，即 EBUSY。
    ```

- **互斥锁解锁**

  - **pthread_mutex_unlock**

    ```c
    #include <pthread.h>
    
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
    功能：
        对指定的互斥锁解锁。
    参数：
        mutex：互斥锁地址。
    返回值：
        成功：0
        失败：非0错误码
    ```

- **示例代码**

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>
  
  #include <pthread.h>
  
  pthread_mutex_t mutex;
  
  void * callback1(void * arg)
  {
  
          pthread_mutex_lock(&mutex);
          for(int i = 'a';i<='z';i++)
          {
  
                  putchar(i);
                  fflush(stdout);
                  usleep(100000);
          }
  
          printf("\n");
          pthread_mutex_unlock(&mutex);
  
  }
  void * callback2(void * arg)
  {
          pthread_mutex_lock(&mutex);
          for(int i = 'A';i<='Z';i++)
          {
  
                  putchar(i);
                  fflush(stdout);
                  usleep(100000);
          }
  
          printf("\n");
          pthread_mutex_unlock(&mutex);
  }
  
  
  int main()
  {
  
          pthread_t tid1;
          pthread_t tid2;
          int ret;
  		//初始化互斥锁
          pthread_mutex_init(&mutex,NULL);
  
  
          ret = pthread_create(&tid1,NULL,callback1,NULL);
          if(ret != 0 )
          {
  
                  printf("pthread_create err... \n");
                  return 1;
          }
  
          ret = pthread_create(&tid2,NULL,callback2,NULL);
          if(ret != 0 )
          {
                  printf("pthread_create err... \n");
                  return 1;
          }
  
          pthread_join(tid1,NULL);
          pthread_join(tid2,NULL);
  		//销毁互斥锁
          pthread_mutex_destroy(&mutex);
  
          return 0;
  }
  ```


## 03. 读写锁

- **概述**

  - 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。

    在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了**读写锁**来实现。

     

    读写锁的特点如下：

    1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。

    2）如果有其它线程写数据，则其它线程都不允许读、写操作。

    

    读写锁分为读锁和写锁，规则如下：

    1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁。

    2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁

## 04. 读写锁相关函数

- **初始化读写锁**

  - **pthread_rwlock_init**

    ```c
    #include <pthread.h>
    
    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
        const pthread_rwlockattr_t *restrict attr);
    功能：
        用来初始化 rwlock 所指向的读写锁。
    
    参数：
        rwlock：指向要初始化的读写锁指针。
        attr：读写锁的属性指针。如果 attr 为 NULL 则会使用默认的属性初始化读写锁，否则使用指定的 attr 初始化读写锁。
    
        可以使用宏 PTHREAD_RWLOCK_INITIALIZER 静态初始化读写锁，比如：
        pthread_rwlock_t my_rwlock = PTHREAD_RWLOCK_INITIALIZER;
    
        这种方法等价于使用 NULL 指定的 attr 参数调用 pthread_rwlock_init() 来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER 宏不进行错误检查。
    
    返回值：
        成功：0，读写锁的状态将成为已初始化和已解锁。
        失败：非 0 错误码。
    ```

- **销毁读写锁**

  - **pthread_rwlock_destroy**

    ```c
    #include <pthread.h>
    
    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
    功能：
        用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init() 自动申请的资源） 。
    参数：
        rwlock：读写锁指针。
    返回值：
        成功：0
        失败：非 0 错误码
    ```

- **申请读锁**

  - **pthread_rwlock_rdlock**

    ```c
    #include <pthread.h>
    
    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    功能：
        以阻塞方式在读写锁上获取读锁（读锁定）。
        如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。
        如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。
        线程可以成功调用 pthread_rwlock_rdlock() 函数 n 次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数 n 次才能解除锁定。
    参数：
        rwlock：读写锁指针。
    返回值：
        成功：0
        失败：非 0 错误码
    
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
       用于尝试以非阻塞的方式来在读写锁上获取读锁。
       如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。
    
    ```

- **申请写锁**

  - **pthread_rwlock_wrlock**

    ```c
    #include <pthread.h>
    
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    功能：
        在读写锁上获取写锁（写锁定）。
        如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁。
        如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。
    参数：
        rwlock：读写锁指针。
    返回值：
        成功：0
        失败：非 0 错误码
    
    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
       用于尝试以非阻塞的方式来在读写锁上获取写锁。
       如果有任何的读者或写者持有该锁，则立即失败返回。
    
    ```

- **读写锁解锁**

  - **pthread_rwlock_unlock**

    ```c
    #include <pthread.h>
    
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
    功能：
        无论是读锁或写锁，都可以通过此函数解锁。
    参数：
        rwlock：读写锁指针。
    返回值：
        成功：0
        失败：非 0 错误
    ```

- **示例代码：**

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>
  
  #include <pthread.h>
  
  pthread_rwlock_t rwLock;
  
  int num = 0;
  
  void * writecallback(void * arg)
  {
          int i = (int)(long)arg;
  
          while(1)
          {
                  pthread_rwlock_wrlock(&rwLock);
                  num++;
                  printf("线程%d，修改数据num = %d\n",i,num);
                  pthread_rwlock_unlock(&rwLock);
                  sleep(random()%3+1);
          }
  
  
  }
  void * readcallback(void * arg)
  {
  
          int i = (int)(long)arg;
  
          while(1)
          {
                  pthread_rwlock_rdlock(&rwLock);
                  printf("线程%d,读取数据num = %d\n",i,num);
                  pthread_rwlock_unlock(&rwLock);
                  sleep(random()%3+1);
          }
  
  }
  
  
  int main()
  {
  
          int ret;
          srandom(getpid());
  
          pthread_t tid[8];
  
          pthread_rwlock_init(&rwLock,NULL);
  
          for(int i = 0; i < 8;i++)
          {
  
                  if(i<5)
                  {
  
                          pthread_create(&tid[i],NULL,readcallback,(void *)(long)i);
                  }
                  else
                  {
                          pthread_create(&tid[i],NULL,writecallback,(void *)(long)i);
  
                  }
  
          }
  
          for(int j = 0;j<8;j++)
          {
                  pthread_join(tid[j],NULL);
          }
  
          pthread_rwlock_destroy(&rwLock);
  
          return 0;
  }
  ```

## 05. 条件变量

- **概述**

  - 与互斥锁不同，条件变量是用来等待而不是用来上锁的，**条件变量本身不是锁**！

    条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。

    条件变量的两个动作：

    - 条件不满, 阻塞线程
    - 当条件满足, 通知阻塞的线程开始工作

    条件变量的类型: pthread_cond_t。

- **初始化条件变量**

  - **pthread_cond_init**

    ```c
    #include <pthread.h>
    
    int pthread_cond_init(pthread_cond_t *restrict cond,
        const pthread_condattr_t *restrict attr);
    功能：
        初始化一个条件变量
    参数：
        cond：指向要初始化的条件变量指针。
        attr：条件变量属性，通常为默认值，传NULL即可
            也可以使用静态初始化的方法，初始化条件变量：
            pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
    返回值：
        成功：0
        失败：非0错误号
    ```

- **销毁条件变量**

  - **pthread_cond_destroy**

    ```c
    #include <pthread.h>
    
    int pthread_cond_destroy(pthread_cond_t *cond);
    功能：
        销毁一个条件变量
    参数：
        cond：指向要初始化的条件变量指针
    返回值：
        成功：0
        失败：非0错误号
    ```

- **阻塞等待一个条件变量**

  - **pthread_cond_wait**

    ```c
    #include <pthread.h>
    
    int pthread_cond_wait(pthread_cond_t *restrict cond,
        pthread_mutex_t *restrict mutex);
    功能：
        阻塞等待一个条件变量
        a) 阻塞等待条件变量cond（参1）满足
        b) 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&mutex);
                a) b) 两步为一个原子操作。
        c) 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&mutex);
    
    参数：
        cond：指向要初始化的条件变量指针
        mutex：互斥锁
    
    返回值：
        成功：0
        失败：非0错误号
    
    int pthread_cond_timedwait(pthread_cond_t *restrict cond,
        pthread_mutex_t *restrict mutex,
        const struct
                               .*restrict abstime);
    功能：
        限时等待一个条件变量
    
    参数：
        cond：指向要初始化的条件变量指针
        mutex：互斥锁
        abstime：绝对时间
    
    返回值：
        成功：0
        失败：非0错误号
    
        
    struct timespec {
        time_t tv_sec;      /* seconds */ // 秒
        long   tv_nsec; /* nanosecondes*/ // 纳秒
    }
    
    time_t cur = time(NULL);        //获取当前时间。
    struct timespec t;              //定义timespec 结构体变量t
    t.tv_sec = cur + 1;             // 定时1秒
    pthread_cond_timedwait(&cond, &t);
    ```

    

- **唤醒阻塞在条件变量的线程**

  - **pthread_cond_signal**

    ```c
    #include <pthread.h>
    
    int pthread_cond_signal(pthread_cond_t *cond);
    功能：
        唤醒至少一个阻塞在条件变量上的线程
    参数：
        cond：指向要初始化的条件变量指针
    返回值：
        成功：0
        失败：非0错误号
    
    int pthread_cond_broadcast(pthread_cond_t *cond);
    功能：
        唤醒全部阻塞在条件变量上的线程
    参数：
        cond：指向要初始化的条件变量指针
    返回值：
        成功：0
        失败：非0错误号
    
    ```


## 06. 生产者与消费者模型

**示例代码**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <pthread.h>

pthread_cond_t cond;
pthread_mutex_t mutex;

struct node
{
        int data;
        struct node * next;
};

struct node * head = NULL;

void * producer(void * arg)
{

        while(1)
        {
                pthread_mutex_lock(&mutex);
                struct node * new = malloc(sizeof(struct node));

                memset(new,0,sizeof(struct node));

                new->data = random()%100+1;
                new->next = NULL;

                new->next = head;
                head = new;

                printf("生产者生产 %d \n",new->data);
                pthread_mutex_unlock(&mutex);

                pthread_cond_signal(&cond);

                sleep(random()%3+1);

        }

}
void * customer(void * arg)
{
        struct node * temp = NULL;

        while(1)
        {
                pthread_mutex_lock(&mutex);


                if(head == NULL)
                {

                        printf("等待生产者生成....\n");
                        pthread_cond_wait(&cond,&mutex);

                }

                temp = head;
                head = head->next;
                printf("消费者消费 %d\n",temp->data);
                free(temp);
                pthread_mutex_unlock(&mutex);

                sleep(random()%3+1);
        }

}


int main()
{

        int ret;
        srandom(getpid());

        pthread_cond_init(&cond,NULL);
        pthread_mutex_init(&mutex,NULL);

        pthread_t tid1,tid2;

        pthread_create(&tid1,NULL,producer,NULL);
        pthread_create(&tid2,NULL,customer,NULL);

        pthread_join(tid1,NULL);
        pthread_join(tid2,NULL);

        pthread_cond_destroy(&cond);
        pthread_mutex_destroy(&mutex);

        return 0;
}
```

## 07. 信号量

- **概述**

  - 信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。

    编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于 0 时，则可以访问，否则将阻塞。

    PV 原语是对信号量的操作，一次 P 操作使信号量减１，一次 V 操作使信号量加１。

    信号量主要用于进程或线程间的同步和互斥这两种典型情况。

    信号量数据类型为：sem_t。

- **初始化信号量**

  - **sem_init**

    ```c
    #include <semaphore.h>
    
    int sem_init(sem_t *sem, int pshared, unsigned int value);
    功能：
        创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。
    参数：
        sem：信号量的地址。
        pshared：等于 0，信号量在线程间共享（常用）；不等于0，信号量在进程间共享。
        value：信号量的初始值。
    返回值：
        成功：0
        失败： - 1
    ```

- **销毁信号量**

  - **sem_destroy**

    ```c
    #include <semaphore.h>
    
    int sem_destroy(sem_t *sem);
    功能：
        删除 sem 标识的信号量。
    参数：
        sem：信号量地址。
    返回值：
        成功：0
        失败： - 1
    ```

- **信号量P操作 (减1)**

  - **sem_wait**

    ```c
    #include <semaphore.h>
    
    int sem_wait(sem_t *sem);
    功能：
        将信号量的值减 1。操作前，先检查信号量（sem）的值是否为 0，若信号量为 0，此函数会阻塞，直到信号量大于 0 时才进行减 1 操作。
    参数：
        sem：信号量的地址。
    返回值：
        成功：0
        失败： - 1
    
    int sem_trywait(sem_t *sem);
       以非阻塞的方式来对信号量进行减 1 操作。
       若操作前，信号量的值等于 0，则对信号量的操作失败，函数立即返回。
    
    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
       限时尝试将信号量的值减 1
       abs_timeout：绝对时间
        
    struct timespec {
        time_t tv_sec;      /* seconds */ // 秒
        long   tv_nsec; /* nanosecondes*/ // 纳秒
    }
    
    time_t cur = time(NULL);        //获取当前时间。
    struct timespec t;              //定义timespec 结构体变量t
    t.tv_sec = cur + 1;             // 定时1秒
    sem_timedwait(&cond, &t);
    ```

- **信号量V操作 (加1)**

  - **sem_post**

    ```c
    #include <semaphore.h>
    
    int sem_post(sem_t *sem);
    功能：
        将信号量的值加 1 并发出信号唤醒等待线程（sem_wait()）。
    参数：
        sem：信号量的地址。
    返回值：
        成功：0
        失败：-1
    ```

- **获取信号量的值**

  - **sem_getvalue**

    ```c
    #include <semaphore.h>
    
    int sem_getvalue(sem_t *sem, int *sval);
    功能：
        获取 sem 标识的信号量的值，保存在 sval 中。
    参数：
        sem：信号量地址。
        sval：保存信号量值的地址。
    返回值：
        成功：0
        失败：-1
    
    ```

